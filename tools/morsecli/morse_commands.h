/*
 * Copyright 2024-2025 Morse Micro
 * SPDX-License-Identifier: GPL-2.0-or-later OR LicenseRef-MorseMicroCommercial
 *
 * Morsectrl - Host Interface API
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 */

#ifndef MORSE_COMMANDS_H_
#define MORSE_COMMANDS_H_

#include <stdint.h>

#ifdef MORSE_WIN_BUILD
#include <winsock2.h>
#include <windows.h>
#endif

#define PACKED                 __attribute__((packed))

#define MORSE_CMD_SEMVER_MAJOR 56
#define MORSE_CMD_SEMVER_MINOR 3
#define MORSE_CMD_SEMVER_PATCH 0

#define MORSE_CMD_TYPE_REQ     BIT(0)
#define MORSE_CMD_TYPE_RESP    BIT(1)
#define MORSE_CMD_TYPE_EVT     BIT(2)

#define MORSE_CMD_SSID_MAX_LEN 32
#define MORSE_CMD_MAC_ADDR_LEN 6

enum morse_cmd_id
{
    /* Standard commands starting at 0x0000 */
    MORSE_CMD_ID_SET_CHANNEL = 0x0001,
    MORSE_CMD_ID_GET_VERSION = 0x0002,
    MORSE_CMD_ID_ADD_INTERFACE = 0x0004,
    MORSE_CMD_ID_REMOVE_INTERFACE = 0x0005,
    MORSE_CMD_ID_BSS_CONFIG = 0x0006,
    MORSE_CMD_ID_RPG = 0x0009,
    MORSE_CMD_ID_DISABLE_KEY = 0x000B,
    MORSE_CMD_ID_SCAN_CONFIG = 0x0010,
    MORSE_CMD_ID_GET_CHANNEL_FULL = 0x0013,
    MORSE_CMD_ID_SET_STA_STATE = 0x0014,
    MORSE_CMD_ID_SET_BSS_COLOR = 0x0015,
    MORSE_CMD_ID_HEALTH_CHECK = 0x0019,
    MORSE_CMD_ID_CTS_SELF_PS = 0x001A,
    MORSE_CMD_ID_GET_CHANNEL_DTIM = 0x001C,
    MORSE_CMD_ID_GET_CHANNEL = 0x001D,
    MORSE_CMD_ID_SET_LONG_SLEEP_CONFIG = 0x0021,
    MORSE_CMD_ID_SET_DUTY_CYCLE = 0x0022,
    MORSE_CMD_ID_GET_DUTY_CYCLE = 0x0023,
    MORSE_CMD_ID_GET_MAX_TXPOWER = 0x0024,
    MORSE_CMD_ID_MAC_ADDR = 0x0029,
    MORSE_CMD_ID_MPSW_CONFIG = 0x0030,
    MORSE_CMD_ID_STANDBY_MODE = 0x0031,
    MORSE_CMD_ID_DHCP_OFFLOAD = 0x0032,
    MORSE_CMD_ID_SET_KEEP_ALIVE_OFFLOAD = 0x0033,
    MORSE_CMD_ID_UAPSD_CONFIG = 0x0040,
    MORSE_CMD_ID_SET_WHITELIST = 0x0045,
    MORSE_CMD_ID_ARP_PERIODIC_REFRESH = 0x0046,
    MORSE_CMD_ID_SET_TCP_KEEPALIVE = 0x0047,
    MORSE_CMD_ID_FORCE_POWER_MODE = 0x0048,
    MORSE_CMD_ID_NET_IP = 0x004D,
    MORSE_CMD_ID_TCP_PERIODIC = 0x004E,

    /* Stats commands starting at 0x2000 */
    MORSE_CMD_ID_HOST_STATS_LOG = 0x2007,
    MORSE_CMD_ID_HOST_STATS_RESET = 0x2008,
    MORSE_CMD_ID_MAC_STATS_LOG = 0x200C,
    MORSE_CMD_ID_MAC_STATS_RESET = 0x200D,
    MORSE_CMD_ID_UPHY_STATS_LOG = 0x200E,
    MORSE_CMD_ID_UPHY_STATS_RESET = 0x200F,

    /* Driver commands starting at 0xA000 */
    MORSE_CMD_ID_DRIVER_START = 0xA000,
    MORSE_CMD_ID_SET_LISTEN_INTERVAL = 0xA003,
    MORSE_CMD_ID_SET_AMPDU = 0xA004,
    MORSE_CMD_ID_COREDUMP = 0xA006,
    MORSE_CMD_ID_SET_S1G_OP_CLASS = 0xA007,
    MORSE_CMD_ID_SEND_WAKE_ACTION_FRAME = 0xA008,
    MORSE_CMD_ID_VENDOR_IE_CONFIG = 0xA009,
    MORSE_CMD_ID_SET_TWT_CONF = 0xA010,
    MORSE_CMD_ID_GET_AVAILABLE_CHANNELS = 0xA011,
    MORSE_CMD_ID_SET_ECSA_S1G_INFO = 0xA012,
    MORSE_CMD_ID_GET_HW_VERSION = 0xA013,
    MORSE_CMD_ID_CAC = 0xA014,
    MORSE_CMD_ID_DRIVER_SET_DUTY_CYCLE = 0xA015,
    MORSE_CMD_ID_MBSSID = 0xA016,
    MORSE_CMD_ID_SET_MESH_CONFIG = 0xA018,
    MORSE_CMD_ID_SET_MCBA_CONF = 0xA019,
    MORSE_CMD_ID_DYNAMIC_PEERING_CONFIG = 0xA020,
    MORSE_CMD_ID_CONFIG_RAW = 0xA021,
    MORSE_CMD_ID_DRIVER_END,

    /* Fullmac commands starting at 0x0800 */
    MORSE_CMD_ID_GET_RC_STATS = 0x0806,

    /* Temporary commands starting at 0x1000 */
    MORSE_CMD_ID_SET_TX_PKT_LIFETIME_USECS = 0x100C,
    MORSE_CMD_ID_SET_PHYSM_WATCHDOG = 0x100D,
    MORSE_CMD_ID_TX_POLAR = 0x100E,

    /* Test commands starting at 0x8000 */
    MORSE_CMD_ID_OTP = 0x8014,
    MORSE_CMD_ID_MAX_AMPDU_LENGTH = 0x8016,
    MORSE_CMD_ID_MEDIUM_EVAL = 0x811C,

    /* The get/set parameter command at 0x003E */
    MORSE_CMD_ID_GET_SET_GENERIC_PARAM = 0x003E,

    /* Deprecated commands - do not use */
    MORSE_CMD_ID_HOST_STATS_LOG_DEPRECATED = 0x0007,
    MORSE_CMD_ID_MAC_STATS_LOG_DEPRECATED = 0x000C,
    MORSE_CMD_ID_UPHY_STATS_LOG_DEPRECATED = 0x000E,
    MORSE_CMD_ID_BLOCKACK = 0x0017,
    MORSE_CMD_ID_CFG_ACI_SCAN = 0x001F,
    MORSE_CMD_ID_START_SAMPLE_PLAY = 0x8002,
    MORSE_CMD_ID_STOP_SAMPLE_PLAY = 0x8003,
    MORSE_CMD_ID_SEND_PACKET_AS_AMPDU = 0x8004,
    MORSE_CMD_ID_SET_MAC_ACK_TIMEOUT = 0x8008,
    MORSE_CMD_ID_SPOOF_MANAGED_CALIBRATION = 0x8010,
    MORSE_CMD_ID_SET_RAW_DEPRECATED = 0xA005,
};

/**
 * MAC address structure
 */
struct PACKED morse_cmd_mac_addr
{
    uint8_t octet[MORSE_CMD_MAC_ADDR_LEN];
};

enum morse_cmd_ocs_subcmd
{
    MORSE_CMD_OCS_SUBCMD_CONFIG = 1,
    MORSE_CMD_OCS_SUBCMD_STATUS = 2,
};

/**
 * The header for a command
 */
struct PACKED morse_cmd_header
{
    /** Flags - used between host and firmware */
    __le16 flags;
    /** Message id - from enum morse_commands_id */
    __le16 message_id;
    /** Command length excluding the header */
    __le16 len;
    /** Host sequence id - used between host and firmware only */
    __le16 host_id;
    /** Interface id - set by the host and copied into the response */
    __le16 vif_id;
    /** Padding for word alignment */
    __le16 pad;
};

/**
 * Setting this value in the `SET_CHANNEL` command will cause the currently configured bandwidth to
 * be used.
 */
#define MORSE_CMD_CHANNEL_BW_NOT_SET 0xFF

/**
 * Setting this value in the `SET_CHANNEL` command will cause the currently configured channel index
 * to be used.
 */
#define MORSE_CMD_CHANNEL_IDX_NOT_SET 0xFF

/**
 * Setting this value in the `SET_CHANNEL` command will cause the currently configured frequency to
 * be used.
 */
#define MORSE_CMD_CHANNEL_FREQ_NOT_SET 0xFFFFFFFF

enum morse_cmd_dot11_proto_mode
{
    /** 802.11ah S1G mode */
    MORSE_CMD_DOT11_PROTO_MODE_AH = 0,
    /** 802.11b (DSSS only) mode */
    MORSE_CMD_DOT11_PROTO_MODE_B = 1,
    /** 802.11bg (Legacy only) mode */
    MORSE_CMD_DOT11_PROTO_MODE_BG = 2,
    /** 802.11gn (OFDM only) mode */
    MORSE_CMD_DOT11_PROTO_MODE_GN = 3,
    /** 802.11bgn (Full compatibility) mode */
    MORSE_CMD_DOT11_PROTO_MODE_BGN = 4,
    /** Invalid mode, PHY is not configured */
    MORSE_CMD_DOT11_PROTO_MODE_INVALID = 5,
};

/**
 * @brief Request message for SET_CHANNEL
 *
 * In 802.11ah a BSS supports operating channel widths of 1, 2, 4, 8 and 16 MHz
 * and is required to use a 1MHz or 2MHz primary channel width.
 * Additionally 11ah requires that a 1MHz sub band channel must be available at all
 * operating channel widths regardless of the primary channel width.
 * The location of the 1MHz channel must be contained within the 1/2MHz primary channel.
 * The location of the 1MHz channel within the operating channel can be defined with
 * an integer index.
 *
 * For example, shown is an 8MHz operating channel with a 2MHz primary bandwidth
 * and the 1MHz channel at index 1:
 *
 * | <--------- 8MHz operating channel ----------> | Operating channel
 * | ----4MHz primary----- | ----4MHz secondary--- | 8MHz packet
 * | 2MHz Prim | 2MHz Sec  | --------------------- | 4MHz packet
 * | 2MHz Prim | --------------------------------- | 2MHz packet
 * | --- | 1MH | --------------------------------- | 1MHz packet
 *
 * | -0- | -1- | -2- | -3- | -4- | -5- | -6- | -7- | 1MHz Channel index
 * | ----0---- | ----1---- | ----2---- | ----3---- | 2MHz Channel index
 * | ----------0---------- | ----------1---------- | 4MHz Channel index
 * | ----------------------0---------------------- | 8MHz Channel index
 *
 * The index of the next higher sub band can be calculated by
 * floor(primary_1mhz_channel_index / sub_band_width).
 * E.g. if the 1MHz channel index is 3, the 2MHz primary is at floor(3/2) = 1
 */
struct PACKED morse_cmd_req_set_channel
{
    /** Center frequency of the operating channel */
    __le32 op_chan_freq_hz;
    /** Operating channel bandwidth in MHz */
    uint8_t op_bw_mhz;
    /** Primary channel bandwidth in MHz */
    uint8_t pri_bw_mhz;
    /**
     * The index of the 1MHz channel within the operating channel. This is a value 0 for 1MHz
     * channel, 0-1 for 2MHz, 0-3 for 4MHz, 0-7 for 8MHz and 0-15 for 16MHz.
     */
    uint8_t pri_1mhz_chan_idx;
    /** enum morse_cmd_dot11_proto_mode */
    uint8_t dot11_mode;
    /**
     * Flag set to 1 to set the S1G TX power to the regulatory max, 0 to skip setting. 1 by default.
     * Used for debug on the driver only. Excluded from firmware.
     */
    uint8_t reg_tx_power_set;
};

/**
 * @brief Response message for SET_CHANNEL
 *
 * Returns the power of the channel set
 */
struct PACKED morse_cmd_resp_set_channel
{
    /** Power in qdBm */
    __sle32 power_qdbm;
};

/**
 * @brief Request message for GET_CHANNEL
 *
 * Get the current channel from the firmware
 */
struct PACKED morse_cmd_req_get_channel
{
};

/**
 * @brief Response message for GET_CHANNEL
 *
 * Confirm message for get current channel
 */
struct PACKED morse_cmd_resp_get_channel
{
    /** Centre frequency of the operating channel */
    __le32 op_chan_freq_hz;
    /** Operating channel bandwidth in MHz */
    uint8_t op_chan_bw_mhz;
    /** Primary channel bandwidth in MHz */
    uint8_t pri_chan_bw_mhz;
    /**
     * The index of the 1MHz channel within the operating channel. This is a value 0 for 1MHz
     * channel, 0-1 for 2MHz, 0-3 for 4MHz, 0-7 for 8MHz and 0-15 for 16MHz.
     */
    uint8_t pri_1mhz_chan_idx;
};

/** Maximum length of the version string */
#define MORSE_CMD_MAX_VERSION_LEN 128

/**
 * @brief Request message for GET_VERSION
 */
struct PACKED morse_cmd_req_get_version
{
};

/**
 * @brief Response message for GET_VERSION
 *
 * Structure for a get version confirm
 */
struct PACKED morse_cmd_resp_get_version
{
    /** Length of version */
    __sle32 length;
    /**
     * The version string. Variable length for the firmware. Use MORSE_CMD_MAX_VERSION_LEN to set
     * size elsewhere.
     */
    uint8_t version[];
};

/**
 * @brief Request message for GET_MAX_TXPOWER
 *
 * Retrieve the maximum TX power that the chip can do
 */
struct PACKED morse_cmd_req_get_max_txpower
{
};

/**
 * @brief Response message for GET_MAX_TXPOWER
 */
struct PACKED morse_cmd_resp_get_max_txpower
{
    /** Power in qdBm */
    __sle32 power_qdbm;
};

enum morse_cmd_interface_type
{
    /** An invalid interface type */
    MORSE_CMD_INTERFACE_TYPE_INVALID = 0,
    /** A station interface */
    MORSE_CMD_INTERFACE_TYPE_STA = 1,
    /** An access point interface */
    MORSE_CMD_INTERFACE_TYPE_AP = 2,
    /** A monitor mode interface */
    MORSE_CMD_INTERFACE_TYPE_MON = 3,
    /** Independent BSS (IBSS) interface */
    MORSE_CMD_INTERFACE_TYPE_ADHOC = 4,
    /** Mesh interface */
    MORSE_CMD_INTERFACE_TYPE_MESH = 5,
    /** The last valid interface type */
    MORSE_CMD_INTERFACE_TYPE_LAST = MORSE_CMD_INTERFACE_TYPE_MESH,
};

/**
 * @brief Request message for ADD_INTERFACE
 */
struct PACKED morse_cmd_req_add_interface
{
    /** The address for the interface */
    struct morse_cmd_mac_addr addr;
    /** The interface type */
    __le32 interface_type;
};

/**
 * @brief Response message for ADD_INTERFACE
 */
struct PACKED morse_cmd_resp_add_interface
{
};

/**
 * @brief Request message for REMOVE_INTERFACE
 */
struct PACKED morse_cmd_req_remove_interface
{
};

/**
 * @brief Response message for REMOVE_INTERFACE
 */
struct PACKED morse_cmd_resp_remove_interface
{
};

/**
 * @brief Request message for BSS_CONFIG
 *
 * @note If this command is confirmed with status success, then the AP is active and firmware will
 * start to generate interrupts requesting a beacon
 */
struct PACKED morse_cmd_req_bss_config
{
    /** The beacon interval in TUs */
    __le16 beacon_interval_tu;
    /** The DTIM period */
    __le16 dtim_period;
    /** Padding to maintain aligned access */
    uint8_t __padding[2];
    /** The compressed ssid */
    __le32 cssid;
};

/**
 * @brief Response message for BSS_CONFIG
 */
struct PACKED morse_cmd_resp_bss_config
{
};

enum morse_cmd_rpg_id
{
    MORSE_CMD_RPG_ID_START_TX = 256,
    MORSE_CMD_RPG_ID_STOP_TX = 257,
    MORSE_CMD_RPG_ID_GET_STATS = 258,
    MORSE_CMD_RPG_ID_RESET_STATS = 259,
    MORSE_CMD_RPG_ID_SET_SOURCE_ADDR = 260,
    MORSE_CMD_RPG_ID_SET_DEST_ADDR = 261,
    MORSE_CMD_RPG_ID_FORCE_AMPDU = 262,
    MORSE_CMD_RPG_ID_FORCE_TX_RETRY = 263,
};

/**
 *
 */
struct PACKED morse_cmd_rpg_start_tx
{
    /** Size of RPG packets to be sent */
    __sle32 size;
    /** Number of RPG packets to send */
    __sle32 count;
    /** Enable random packet data */
    uint8_t enable_random;
};

/**
 * Set source mac address for RPG command
 */
struct PACKED morse_cmd_rpg_set_source_addr
{
    struct morse_cmd_mac_addr source;
};

/**
 * Set destination mac address for RPG command
 */
struct PACKED morse_cmd_rpg_set_destination_addr
{
    struct morse_cmd_mac_addr destination;
};

/**
 * Force the use of AMPDUs in RPG commands
 */
struct PACKED morse_cmd_rpg_force_ampdu
{
    /** Maximum number of frames that can be aggregated */
    __sle32 number;
};

/**
 * Force RPG tx retries
 */
struct PACKED morse_cmd_rpg_force_tx_retry
{
    /** Bitmap of the MPDUs that should be failed, and re-aggregated */
    __le32 bitmap;
};

/**
 * Format of RPG statistics
 */
struct PACKED morse_cmd_rpg_stats
{
    __le32 total_rx_packets;
    __le32 total_rx_packets_w_correct_fcs;
    __le32 total_tx_packets;
    __le32 rx_signal_field_errors;
};

/**
 * RPG statistics for morse_cmd_resp_rpg
 */
struct PACKED morse_cmd_rpg_resp_get_statistics
{
    struct morse_cmd_rpg_stats stats;
};

/**
 * @brief Request message for RPG
 *
 * RPG shouldn't be enabled during normal driver operation
 */
struct PACKED morse_cmd_req_rpg
{
    /** RPG subcommand @ref morse_cmd_rpg_id */
    __le16 sub_cmd;

    union
    {
        uint8_t opaque[0];
        struct morse_cmd_rpg_start_tx start;
        struct morse_cmd_rpg_set_source_addr set_source;
        struct morse_cmd_rpg_set_destination_addr set_destination;
        struct morse_cmd_rpg_force_ampdu force_ampdu;
        struct morse_cmd_rpg_force_tx_retry force_tx_retry;
    };
};

/**
 * @brief Response message for RPG
 */
struct PACKED morse_cmd_resp_rpg
{
    union
    {
        uint8_t opaque[0];
        struct morse_cmd_rpg_resp_get_statistics stats;
    };
};

/**
 * @brief Request message for SCAN_CONFIG
 */
struct PACKED morse_cmd_req_scan_config
{
    /** MAC scan state */
    uint8_t enabled;
    /** Will report noise level on each channel in the scan when set */
    uint8_t is_survey;
};

/**
 * @brief Response message for SCAN_CONFIG
 */
struct PACKED morse_cmd_resp_scan_config
{
};


/** STA Flag to notify PV1 */
#define MORSE_CMD_STA_FLAG_S1G_PV1 BIT(0)

/**
 * @brief Request message for SET_STA_STATE
 */
struct PACKED morse_cmd_req_set_sta_state
{
    /** MAC address of the station */
    uint8_t sta_addr[MORSE_CMD_MAC_ADDR_LEN];
    /** The STA association identifier */
    __le16 aid;
    /** Station IEEE80211 state @ref morse_cmd_ieee80211_sta_state */
    __le16 state;
    /** U-APSD queues */
    uint8_t uapsd_queues;
    /** Morse STA Flag @ref MORSE_CMD_STA_FLAG_S1G_PV1 */
    __le32 flags;
};

/**
 * @brief Response message for SET_STA_STATE
 */
struct PACKED morse_cmd_resp_set_sta_state
{
};

/**
 * @brief Request message for SET_BSS_COLOR
 */
struct PACKED morse_cmd_req_set_bss_color
{
    /** The BSS color */
    uint8_t bss_color;
};

/**
 * @brief Response message for SET_BSS_COLOR
 */
struct PACKED morse_cmd_resp_set_bss_color
{
};

/**
 * @brief Request message for HEALTH_CHECK
 */
struct PACKED morse_cmd_req_health_check
{
};

/**
 * @brief Response message for HEALTH_CHECK
 */
struct PACKED morse_cmd_resp_health_check
{
};

/**
 * @brief Request message for CTS_SELF_PS
 *
 * Enable/disable CTS-to-self PS beacon mode
 */
struct PACKED morse_cmd_req_cts_self_ps
{
    uint8_t enable;
};

/**
 * @brief Response message for CTS_SELF_PS
 */
struct PACKED morse_cmd_resp_cts_self_ps
{
};

/**
 * @brief Request message for SET_LONG_SLEEP_CONFIG
 *
 * @note This is used for WNM sleep to enable us to go deaf to traffic
 */
struct PACKED morse_cmd_req_set_long_sleep_config
{
    /** Enable/disable long sleep */
    uint8_t enabled;
};

/**
 * @brief Response message for SET_LONG_SLEEP_CONFIG
 */
struct PACKED morse_cmd_resp_set_long_sleep_config
{
};

#define MORSE_CMD_DUTY_CYCLE_SET_CFG_DUTY_CYCLE        BIT(0)
#define MORSE_CMD_DUTY_CYCLE_SET_CFG_OMIT_CONTROL_RESP BIT(1)
#define MORSE_CMD_DUTY_CYCLE_SET_CFG_EXT               BIT(2)
#define MORSE_CMD_DUTY_CYCLE_SET_CFG_BURST_RECORD_UNIT BIT(3)

enum morse_cmd_duty_cycle_mode
{
    MORSE_CMD_DUTY_CYCLE_MODE_SPREAD = 0,
    MORSE_CMD_DUTY_CYCLE_MODE_BURST = 1,
    MORSE_CMD_DUTY_CYCLE_MODE_LAST = MORSE_CMD_DUTY_CYCLE_MODE_BURST,
};

/**
 * Set duty cycle configuration
 */
struct PACKED morse_cmd_duty_cycle_configuration
{
    /** Omit control responses from duty cycle budget */
    uint8_t omit_control_responses;
    /** Target duty cycle in 100th of a %, i.e. 1..10000 */
    __le32 duty_cycle;
};

/**
 * Extension parameters for the duty cycle exit
 */
struct PACKED morse_cmd_duty_cycle_set_configuration_ext
{
    /** The length of each burst record in the window (usecs) - applicable in burst mode only */
    __le32 burst_record_unit_us;
    /** Duty cycle mode, see @ref enum morse_cmd_duty_cycle_mode */
    uint8_t mode;
};

/**
 * Set duty cycle exit configuration
 */
struct PACKED morse_cmd_duty_cycle_configuration_ext
{
    /** Airtime remaining (us) - applicable in burst mode only */
    __le32 airtime_remaining_us;
    /** Burst window duration (us) - applicable in burst mode only */
    __le32 burst_window_duration_us;
    /** Extension parameters that are configured */
    struct morse_cmd_duty_cycle_set_configuration_ext set;
};

/**
 * @brief Request message for SET_DUTY_CYCLE
 */
struct PACKED morse_cmd_req_set_duty_cycle
{
    struct morse_cmd_duty_cycle_configuration config;
    uint8_t set_cfgs;
    struct morse_cmd_duty_cycle_set_configuration_ext config_ext;
};

/**
 * @brief Response message for GET_DUTY_CYCLE
 */
struct PACKED morse_cmd_resp_get_duty_cycle
{
    struct morse_cmd_duty_cycle_configuration config;
    struct morse_cmd_duty_cycle_configuration_ext config_ext;
};

/**
 * @brief Request message for MAC_ADDR
 */
struct PACKED morse_cmd_req_mac_addr
{
    uint8_t write;
    uint8_t octet[MORSE_CMD_MAC_ADDR_LEN];
};

/**
 * @brief Response message for MAC_ADDR
 */
struct PACKED morse_cmd_resp_mac_addr
{
    uint8_t octet[MORSE_CMD_MAC_ADDR_LEN];
};

#define MORSE_CMD_SET_MPSW_CFG_AIRTIME_BOUNDS  BIT(0)
#define MORSE_CMD_SET_MPSW_CFG_PKT_SPC_WIN_LEN BIT(1)
#define MORSE_CMD_SET_MPSW_CFG_ENABLED         BIT(2)

/**
 * MPSW configuration structure
 */
struct PACKED morse_cmd_mpsw_configuration
{
    /** The maximum allowable packet airtime duration */
    __le32 airtime_max_us;
    /** The minimum packet airtime duration to trigger spacing */
    __le32 airtime_min_us;
    /** The length of time to close the tx window between packets */
    __le32 packet_space_window_length_us;
    /** Whether to enable airtime bounds checking and packet spacing enforcement */
    uint8_t enable;
};

/**
 * @brief Request message for MPSW_CONFIG
 */
struct PACKED morse_cmd_req_mpsw_config
{
    struct morse_cmd_mpsw_configuration config;
    uint8_t set_cfgs;
};

/**
 * @brief Response message for MPSW_CONFIG
 */
struct PACKED morse_cmd_resp_mpsw_config
{
    struct morse_cmd_mpsw_configuration config;
};

/**
 * @brief Request message for DISABLE_KEY
 */
struct PACKED morse_cmd_req_disable_key
{
    /** The temporal key type @ref morse_cmd_temporal_key_type */
    __le32 key_type;
    /** AID for the station to install. Set to 0 if this is for an AP. */
    __le32 aid;
    /** The key index maps to index in chip */
    uint8_t key_idx;
};

/**
 * @brief Response message for DISABLE_KEY
 */
struct PACKED morse_cmd_resp_disable_key
{
};

/** The maximum length of a user-specified payload (bytes) for Standby status frames */
#define MORSE_CMD_STANDBY_STATUS_FRAME_USER_PAYLOAD_MAX_LEN 64

/** The maximum allowed length of a user filter to apply to wake frames */
#define MORSE_CMD_STANDBY_WAKE_FRAME_USER_FILTER_MAX_LEN 64

enum morse_cmd_standby_mode
{
    /** The external host is indicating that it's now awake */
    MORSE_CMD_STANDBY_MODE_EXIT = 0,
    /** The external host is indicating that it's going into standby mode */
    MORSE_CMD_STANDBY_MODE_ENTER = 1,
    /** This version of the config command has since been deprecated (see v3 below) */
    MORSE_CMD_STANDBY_MODE_SET_CONFIG_V1 = 2,
    /** The external host provides a payload that gets appended to status frames */
    MORSE_CMD_STANDBY_MODE_SET_STATUS_PAYLOAD = 3,
    /** The external host provides a filter to be applied to incoming standby wake frames */
    MORSE_CMD_STANDBY_MODE_SET_WAKE_FILTER = 4,
    /** This version of the config command has since been deprecated (see v3 below) */
    MORSE_CMD_STANDBY_MODE_SET_CONFIG_V2 = 5,
    /** The external host sets a number of configuration options for standby mode */
    MORSE_CMD_STANDBY_MODE_SET_CONFIG_V3 = 6,
};

enum morse_cmd_standby_mode_exit_reason
{
    /** No specific reason for exiting standby mode */
    MORSE_CMD_STANDBY_MODE_EXIT_REASON_NONE = 0,
    /** The STA has received the wakeup frame */
    MORSE_CMD_STANDBY_MODE_EXIT_REASON_WAKEUP_FRAME = 1,
    /** The STA needs to (re)associate */
    MORSE_CMD_STANDBY_MODE_EXIT_REASON_ASSOCIATE = 2,
    /** The STA's external input pin has fired */
    MORSE_CMD_STANDBY_MODE_EXIT_REASON_EXT_INPUT = 3,
    /** Whitelisted packet received */
    MORSE_CMD_STANDBY_MODE_EXIT_REASON_WHITELIST_PKT = 4,
    /** TCP connection lost */
    MORSE_CMD_STANDBY_MODE_EXIT_REASON_TCP_CONNECTION_LOST = 5,
    /** HW scan is not enabled */
    MORSE_CMD_STANDBY_MODE_EXIT_REASON_HW_SCAN_NOT_ENABLED = 6,
    /** HW scan failed to start */
    MORSE_CMD_STANDBY_MODE_EXIT_REASON_HW_SCAN_FAILED_TO_START = 7,
    /** Max exit reason enum value */
    MORSE_CMD_STANDBY_MODE_EXIT_REASON_MAX =
        MORSE_CMD_STANDBY_MODE_EXIT_REASON_HW_SCAN_FAILED_TO_START,
};

enum morse_cmd_ieee80211_sta_state
{
    MORSE_CMD_IEEE80211_STA_STATE_NOTEXIST = 0,
    MORSE_CMD_IEEE80211_STA_STATE_NONE = 1,
    MORSE_CMD_IEEE80211_STA_STATE_AUTHENTICATED = 2,
    MORSE_CMD_IEEE80211_STA_STATE_ASSOCIATED = 3,
    MORSE_CMD_IEEE80211_STA_STATE_AUTHORIZED = 4,
    MORSE_CMD_IEEE80211_STA_STATE_AUTHORIZED_ASLEEP = 5,
};

/**
 * Standby configuration structure
 */
struct PACKED morse_cmd_standby_set_config
{
    /** Interval for transmitting Standby status packets */
    __le32 notify_period_s;
    /** Period of inactivity (traffic directed to STA) before external host triggers standby mode */
    __le32 bss_inactivity_before_deep_sleep_s;
    /** Time for firmware to remain in deep sleep in seconds */
    __le32 deep_sleep_period_s;
    /** Source IP address */
    __le32 src_ip;
    /** Destination IP address */
    __le32 dst_ip;
    /** Destination UDP port */
    __le16 dst_port;
    /** Padding for word aligned access in config. (It may grow in future) */
    uint8_t pad[2];
    /** Time in seconds to increment each successive deep sleep */
    __le32 deep_sleep_increment_s;
    /** Max time to deep sleep for */
    __le32 deep_sleep_max_s;
    /** Number of deep sleeps iterations between scans */
    __le32 deep_sleep_scan_iterations;
};

/**
 * Set standby mode status payload structure
 */
struct PACKED morse_cmd_standby_set_status_payload
{
    /** The length of the payload */
    __le32 len;
    /** The payload */
    uint8_t payload[MORSE_CMD_STANDBY_STATUS_FRAME_USER_PAYLOAD_MAX_LEN];
};

/**
 * Set standby mode enter structure
 */
struct PACKED morse_cmd_standby_enter
{
    /** The BSSID to monitor for activity (or lack thereof) before entering deep sleep */
    struct morse_cmd_mac_addr monitor_bssid;
};

/**
 * Set standby mode wake filter structure
 */
struct PACKED morse_cmd_standby_set_wake_filter
{
    /** The length of the wake filter */
    __le32 len;
    /** The offset at which to apply the wake filter */
    __le32 offset;
    /** The user-defined filter */
    uint8_t filter[MORSE_CMD_STANDBY_WAKE_FRAME_USER_FILTER_MAX_LEN];
};

/**
 * Standby mode exit response structure
 */
struct PACKED morse_cmd_standby_mode_exit
{
    /** Reason for exiting Standby mode, see @ref morse_cmd_standby_mode_exit_reason */
    uint8_t reason;
    /** Current connection state */
    uint8_t sta_state;
};

/**
 * @brief Request message for STANDBY_MODE
 *
 * Structure for Configuring MM standby mode
 */
struct PACKED morse_cmd_req_standby_mode
{
    /** Standby Mode subcommands, see @ref morse_cmd_standby_mode */
    __le32 cmd;

    union
    {
        uint8_t opaque[0];
        /** Valid for MORSE_CMD_STANDBY_MODE_SET_CONFIG cmd */
        struct morse_cmd_standby_set_config config;
        /** Valid for MORSE_CMD_STANDBY_MODE_SET_STATUS_PAYLOAD cmd */
        struct morse_cmd_standby_set_status_payload set_payload;
        /** Valid for MORSE_CMD_STANDBY_MODE_ENTER cmd */
        struct morse_cmd_standby_enter enter;
        /** Valid for MORSE_CMD_STANDBY_MODE_SET_WAKE_FILTER cmd */
        struct morse_cmd_standby_set_wake_filter set_filter;
    };
};

/**
 * @brief Response message for STANDBY_MODE
 *
 * Response structure for MM standby mode command. For status, see @ref morse_cmd_standby_mode.
 */
struct PACKED morse_cmd_resp_standby_mode
{
    union
    {
        uint8_t opaque[0];
        struct morse_cmd_standby_mode_exit info;
    };
};

enum morse_cmd_dhcp_opcode
{
    /** Enable the DHCP client */
    MORSE_CMD_DHCP_OPCODE_ENABLE = 0,
    /** Do a DHCP discovery and obtain a lease */
    MORSE_CMD_DHCP_OPCODE_DO_DISCOVERY = 1,
    /** Return the current lease */
    MORSE_CMD_DHCP_OPCODE_GET_LEASE = 2,
    /** Clear the current lease */
    MORSE_CMD_DHCP_OPCODE_CLEAR_LEASE = 3,
    /** Trigger a renewal of the current lease */
    MORSE_CMD_DHCP_OPCODE_RENEW_LEASE = 4,
    /** Trigger a rebinding of the current lease */
    MORSE_CMD_DHCP_OPCODE_REBIND_LEASE = 5,
    /** Ask the FW to send a lease update event to the driver */
    MORSE_CMD_DHCP_OPCODE_SEND_LEASE_UPDATE = 6,
};

enum morse_cmd_dhcp_retcode
{
    /** Command completed successfully */
    MORSE_CMD_DHCP_RETCODE_SUCCESS = 0,
    /** DHCP Client is disabled */
    MORSE_CMD_DHCP_RETCODE_NOT_ENABLED = 1,
    /** DHCP Client is already enabled */
    MORSE_CMD_DHCP_RETCODE_ALREADY_ENABLED = 2,
    /** No current bound lease */
    MORSE_CMD_DHCP_RETCODE_NO_LEASE = 3,
    /** DHCP client already has a lease */
    MORSE_CMD_DHCP_RETCODE_HAVE_LEASE = 4,
    /** DHCP client is currently busy (discovering or renewing) */
    MORSE_CMD_DHCP_RETCODE_BUSY = 5,
    /** Invalid vif specified */
    MORSE_CMD_DHCP_RETCODE_BAD_VIF = 6,
};

/**
 * @brief Request message for DHCP_OFFLOAD
 */
struct PACKED morse_cmd_req_dhcp_offload
{
    /** Opcode of command */
    __le32 opcode;
};

/**
 * @brief Response message for DHCP_OFFLOAD
 */
struct PACKED morse_cmd_resp_dhcp_offload
{
    /** Return code of command */
    __le32 retcode;
    /** My leased IP address if command opcode was GET_LEASE */
    __le32 my_ip;
    /** My leased netmask if command opcode was GET_LEASE */
    __le32 netmask;
    /** My leased router address if command opcode was GET_LEASE */
    __le32 router;
    /** Upstream DNS server if command opcode was GET_LEASE */
    __le32 dns;
};

/**
 * @brief Request message for SET_KEEP_ALIVE_OFFLOAD
 */
struct PACKED morse_cmd_req_set_keep_alive_offload
{
    /** The value of the BSS max idle period as it appears in the IE */
    __le16 bss_max_idle_period;
    /** Set to TRUE to interpret the value of BSS max idle period as per 11ah spec */
    uint8_t interpret_as_11ah;
};

/**
 * @brief Request message for UAPSD_CONFIG
 */
struct PACKED morse_cmd_req_uapsd_config
{
    /** Auto trigger enabled/disabled flag */
    uint8_t auto_trigger_enabled;
    /** Timeout(ms) at which frame is triggered */
    __le32 auto_trigger_timeout;
};

/**
 * @brief Response message for UAPSD_CONFIG
 */
struct PACKED morse_cmd_resp_uapsd_config
{
    /** Confirm auto trigger enabled/disabled */
    uint8_t auto_trigger_enabled;
};

#define MORSE_CMD_WHITELIST_FLAGS_CLEAR BIT(0)

/**
 * @brief Request message for SET_WHITELIST
 *
 * @brief Configure whitelist filtering
 */
struct PACKED morse_cmd_req_set_whitelist
{
    /** Flags */
    uint8_t flags;
    /** IP protocol */
    uint8_t ip_protocol;
    /** Link layer protocol */
    __be16 llc_protocol;
    /** Source IP address */
    __be32 src_ip;
    /** Destination IP address */
    __be32 dest_ip;
    /** Netmask */
    __be32 netmask;
    /** TCP or UDP source port */
    __be16 src_port;
    /** TCP or UDP destination port */
    __be16 dest_port;
};

/**
 * Params for arp periodic request
 */
struct PACKED morse_cmd_arp_periodic_params
{
    __le32 refresh_period_s;
    __le32 destination_ip;
    uint8_t send_as_garp;
};

/**
 * @brief Request message for ARP_PERIODIC_REFRESH
 */
struct PACKED morse_cmd_req_arp_periodic_refresh
{
    struct morse_cmd_arp_periodic_params config;
};

#define MORSE_CMD_TCP_KEEPALIVE_SET_CFG_PERIOD         BIT(0)
#define MORSE_CMD_TCP_KEEPALIVE_SET_CFG_RETRY_COUNT    BIT(1)
#define MORSE_CMD_TCP_KEEPALIVE_SET_CFG_RETRY_INTERVAL BIT(2)
#define MORSE_CMD_TCP_KEEPALIVE_SET_CFG_SRC_IP_ADDR    BIT(3)
#define MORSE_CMD_TCP_KEEPALIVE_SET_CFG_DEST_IP_ADDR   BIT(4)
#define MORSE_CMD_TCP_KEEPALIVE_SET_CFG_SRC_PORT       BIT(5)
#define MORSE_CMD_TCP_KEEPALIVE_SET_CFG_DEST_PORT      BIT(6)

/**
 * @brief Request message for SET_TCP_KEEPALIVE
 */
struct PACKED morse_cmd_req_set_tcp_keepalive
{
    uint8_t enabled;
    uint8_t retry_count;
    uint8_t retry_interval_s;
    uint8_t set_cfgs;
    __be32 src_ip;
    __be32 dest_ip;
    __be16 src_port;
    __be16 dest_port;
    __le16 period_s;
};

enum morse_cmd_power_mode
{
    MORSE_CMD_POWER_MODE_SNOOZE = 0,
    MORSE_CMD_POWER_MODE_DEEP_SLEEP = 1,
    MORSE_CMD_POWER_MODE_HIBERNATE = 2,
};

/**
 * @brief Request message for FORCE_POWER_MODE
 */
struct PACKED morse_cmd_req_force_power_mode
{
    /** Mode of operation to force, see @ref enum morse_cmd_power_mode */
    __le32 mode;
};

enum morse_cmd_net_ip_subcmd
{
    MORSE_CMD_NET_IP_SUBCMD_CONFIG = 1,
    MORSE_CMD_NET_IP_SUBCMD_START = 2,
};

enum morse_cmd_net_ip_config_val
{
    MORSE_CMD_NET_IP_CONFIG_VAL_IP = BIT(0),
    MORSE_CMD_NET_IP_CONFIG_VAL_NETMASK = BIT(1),
    MORSE_CMD_NET_IP_CONFIG_VAL_GATEWAY = BIT(2),
    MORSE_CMD_NET_IP_CONFIG_VAL_GATEWAY_MAC = BIT(3),
};

/**
 * Command structure for @ref MORSE_CMD_NET_IP_SUBCMD_CONFIG. Configure the IP information of the
 * local IP endpoint on chip.
 */
struct PACKED morse_cmd_net_ip_configure
{
    /** Bitfield of flags described by @ref morse_cmd_net_ip_config_val */
    __le32 flags;
    /**
     * Local IP address (32-bit network-endian format) to assign to the network endpoint. Specify
     * MORSE_CMD_NET_IP_CONFIG_VAL_IP in flags to set.
     */
    __be32 ip;
    /**
     * Netmask applied to the local IP address (32-bit network-endian format). Specify
     * MORSE_CMD_NET_IP_CONFIG_VAL_NETMASK in flags to set.
     */
    __be32 netmask;
    /**
     * The gateway IP address (32-bit network-endian format). Specify
     * MORSE_CMD_NET_IP_CONFIG_VAL_GATEWAY in flags to set.
     */
    __be32 gateway;
    /** The gateway MAC address. Specify MORSE_CMD_NET_IP_CONFIG_VAL_GATEWAY_MAC in flags to set. */
    uint8_t gateway_mac[MORSE_CMD_MAC_ADDR_LEN];
};

/**
 * @brief Request message for NET_IP
 */
struct PACKED morse_cmd_req_net_ip
{
    /** NET_IP subcommand @ref morse_cmd_net_ip_subcmd */
    __le32 sub_cmd;

    union
    {
        struct morse_cmd_net_ip_configure configure;
    };
};

enum morse_cmd_tcp_periodic_subcmd
{
    MORSE_CMD_TCP_PERIODIC_SUBCMD_CONFIG = 1,
    MORSE_CMD_TCP_PERIODIC_SUBCMD_CONNECT = 2,
    MORSE_CMD_TCP_PERIODIC_SUBCMD_TX = 3,
    MORSE_CMD_TCP_PERIODIC_SUBCMD_DISCONNECT = 4,
};

enum morse_cmd_tcp_periodic_config_val
{
    MORSE_CMD_TCP_PERIODIC_CONFIG_VAL_PERIODICITY = BIT(0),
    MORSE_CMD_TCP_PERIODIC_CONFIG_VAL_PAYLOAD = BIT(1),
    MORSE_CMD_TCP_PERIODIC_CONFIG_VAL_EVT_ON_DISCONNECT = BIT(2),
};

/**
 * Command structure for @ref MORSE_CMD_TCP_PERIODIC_SUBCMD_CONFIG. This command will control the
 * behaviour of TCP transmission.
 */
struct PACKED morse_cmd_tcp_periodic_config
{
    /** Bitfield of flags described by @ref morse_cmd_tcp_periodic_config_val */
    __le32 flags;
    /**
     * Periodicity of transmission (seconds). Specify MORSE_CMD_TCP_PERIODIC_CONFIG_VAL_PERIODICITY
     * in flags to set.
     */
    __le32 periodicity_s;
    /**
     * Length of the payload being set (bytes). Observed when
     * MORSE_CMD_TCP_PERIODIC_CONFIG_VAL_PAYLOAD in flags is set.
     */
    __le32 payload_len;
    /**
     * When set to 1, the chip will generate an event when the socket is closed or disconnected.
     * Specify MORSE_CMD_TCP_PERIODIC_CONFIG_VAL_EVT_ON_DISCONNECT in flags to set or clear.
     */
    __le32 evt_on_disconnect;
    /**
     * The periodic payload to trasmit. Specify MORSE_CMD_TCP_PERIODIC_CONFIG_VAL_PAYLOAD in flags
     * to set.
     */
    uint8_t payload[];
};

/**
 * Command structure for @ref MORSE_CMD_TCP_PERIODIC_SUBCMD_CONNECT. This command will open a TCP
 * socket to {remote ip}:{remote port}. If the MAC address of the remote IP address is known it can
 * be optionally supplied via {remote_mac}.
 */
struct PACKED morse_cmd_tcp_periodic_connect
{
    /** Remote IP address (32-bit network-endian format) */
    __be32 remote_ip;
    /** Remote port (16-bit network-endian format) */
    __be16 remote_port;
    /** Remote MAC address of destination (optional, zeroed) */
    uint8_t remote_mac[MORSE_CMD_MAC_ADDR_LEN];
};

/**
 * @brief Request message for TCP_PERIODIC
 *
 * Under some modes of operation, an offloaded TCP/IP socket may be opened on chip. Arbitrary TCP
 * data can be periodically transmitted from this socket.
 */
struct PACKED morse_cmd_req_tcp_periodic
{
    /** Subcommand @ref morse_cmd_tcp_periodic_subcmd */
    __le32 sub_cmd;

    union
    {
        struct morse_cmd_tcp_periodic_config configure;
        struct morse_cmd_tcp_periodic_connect connect;
    };
};

/**
 * @brief Request message for SET_LISTEN_INTERVAL
 */
struct PACKED morse_cmd_req_set_listen_interval
{
    __le16 listen_interval;
};

/**
 * @brief Request message for SET_AMPDU
 */
struct PACKED morse_cmd_req_set_ampdu
{
    uint8_t ampdu_enabled;
};

/**
 * @brief Request message for SET_S1G_OP_CLASS
 */
struct PACKED morse_cmd_req_set_s1g_op_class
{
    uint8_t opclass;
    uint8_t prim_opclass;
};

/**
 * @brief Request message for SEND_WAKE_ACTION_FRAME
 */
struct PACKED morse_cmd_req_send_wake_action_frame
{
    uint8_t dest_addr[MORSE_CMD_MAC_ADDR_LEN];
    __le32 payload_size;
    uint8_t payload[];
};

#define MORSE_CMD_MAX_VENDOR_IE_LENGTH 255

/** VENDOR_IE_CONFIG management flags */
#define MORSE_CMD_VENDOR_IE_TYPE_FLAG_BEACON     BIT(0)
#define MORSE_CMD_VENDOR_IE_TYPE_FLAG_PROBE_REQ  BIT(1)
#define MORSE_CMD_VENDOR_IE_TYPE_FLAG_PROBE_RESP BIT(2)
#define MORSE_CMD_VENDOR_IE_TYPE_FLAG_ASSOC_REQ  BIT(3)
#define MORSE_CMD_VENDOR_IE_TYPE_FLAG_ASSOC_RESP BIT(4)

enum morse_cmd_vendor_ie_op
{
    MORSE_CMD_VENDOR_IE_OP_ADD_ELEMENT = 0,
    MORSE_CMD_VENDOR_IE_OP_CLEAR_ELEMENTS = 1,
    MORSE_CMD_VENDOR_IE_OP_ADD_FILTER = 2,
    MORSE_CMD_VENDOR_IE_OP_CLEAR_FILTERS = 3,
    MORSE_CMD_VENDOR_IE_OP_INVALID = UINT16_MAX,
};

/**
 * @brief Request message for VENDOR_IE_CONFIG
 */
struct PACKED morse_cmd_req_vendor_ie_config
{
    __le16 opcode;
    __le16 mgmt_type_mask;
    uint8_t data[MORSE_CMD_MAX_VENDOR_IE_LENGTH];
};

/**
 * @brief Response message for VENDOR_IE_CONFIG
 */
struct PACKED morse_cmd_resp_vendor_ie_config
{
};

enum morse_cmd_twt_conf_op
{
    MORSE_CMD_TWT_CONF_OP_CONFIGURE = 0,
    MORSE_CMD_TWT_CONF_OP_FORCE_INSTALL_AGREEMENT = 1,
    MORSE_CMD_TWT_CONF_OP_REMOVE_AGREEMENT = 2,
    MORSE_CMD_TWT_CONF_OP_CONFIGURE_EXPLICIT = 3,
};

/**
 * Explicit declaration of the TWT wake interval as expected from WFA
 */
struct PACKED morse_cmd_explicit_twt_wake_interval
{
    __le16 wake_interval_mantissa;
    uint8_t wake_interval_exponent;
    uint8_t __padding[5];
};

/**
 * Union of the twt wake interval
 */
union PACKED morse_cmd_wake_interval
{
    __le64 wake_interval_us;
    struct morse_cmd_explicit_twt_wake_interval explicit_twt;
};

/**
 * @brief Request message for SET_TWT_CONF
 */
struct PACKED morse_cmd_req_set_twt_conf
{
    /** TWT subcommands, see @ref morse_cmd_twt_conf_op */
    uint8_t opcode;
    /** The flow (twt) identifier for the agreement to set, install or remove */
    uint8_t flow_id;
    /** The target wake time (TSF) for the first TWT service period */
    __le64 target_wake_time;
    /** Wake interval described explicitly or in usecs */
    union morse_cmd_wake_interval wake_interval;
    /** Minimum wake duration during TWT service period (usecs) */
    __le32 wake_duration_us;
    /** TWT setup command to use (0: request, 1: suggest, 2: demand) */
    uint8_t twt_setup_command;
    uint8_t __padding[3];
};

#define MORSE_CMD_MAX_AVAILABLE_CHANNELS 255

/**
 * Channel information for get available channels. Structure should not vary from that of struct
 * morse_channel in dot11ah.h in the driver as channel information is derived from this definition.
 */
struct PACKED morse_cmd_channel_info
{
    __le32 frequency_khz;
    uint8_t channel_5g;
    uint8_t channel_s1g;
    uint8_t bandwidth_mhz;
};

/**
 * @brief Response message for GET_AVAILABLE_CHANNELS
 */
struct PACKED morse_cmd_resp_get_available_channels
{
    __le32 num_channels;
    struct morse_cmd_channel_info channels[MORSE_CMD_MAX_AVAILABLE_CHANNELS];
};

#define MORSE_CMD_S1G_CAP0_S1G_LONG  BIT(0)
#define MORSE_CMD_S1G_CAP0_SGI_1MHZ  BIT(1)
#define MORSE_CMD_S1G_CAP0_SGI_2MHZ  BIT(2)
#define MORSE_CMD_S1G_CAP0_SGI_4MHZ  BIT(3)
#define MORSE_CMD_S1G_CAP0_SGI_8MHZ  BIT(4)
#define MORSE_CMD_S1G_CAP0_SGI_16MHZ BIT(5)

/**
 * @brief Request message for SET_ECSA_S1G_INFO
 */
struct PACKED morse_cmd_req_set_ecsa_s1g_info
{
    /**
     * Operating Channel Frequency Hz. Endianness __le32 op_chan_freq_hz is not considered as the
     * cmd is indicated to driver and not chip.
     */
    __le32 operating_channel_freq_hz;
    /** Global operating class */
    uint8_t opclass;
    /** Primary channel bw in MHz */
    uint8_t primary_channel_bw_mhz;
    /** 1MHz channel index */
    uint8_t prim_1mhz_ch_idx;
    /** Operating channel bandwidth in MHz */
    uint8_t operating_channel_bw_mhz;
    /** Global operating class for primary chan */
    uint8_t prim_opclass;
    uint8_t s1g_cap0;
    uint8_t s1g_cap1;
    uint8_t s1g_cap2;
    uint8_t s1g_cap3;
};

/**
 * @brief Response message for GET_HW_VERSION
 */
struct PACKED morse_cmd_resp_get_hw_version
{
    uint8_t hw_version[64];
};

#define MORSE_CMD_CAC_CFG_CHANGE_RULE_MAX 8
#define MORSE_CMD_CAC_CFG_ARFS_MAX        99
#define MORSE_CMD_CAC_CFG_CHANGE_MAX      99
#define MORSE_CMD_CAC_CFG_CHANGE_STEP     5

enum morse_cmd_cac_op
{
    MORSE_CMD_CAC_OP_DISABLE = 0,
    MORSE_CMD_CAC_OP_ENABLE = 1,
    MORSE_CMD_CAC_OP_CFG_GET = 2,
    MORSE_CMD_CAC_OP_CFG_SET = 3,
};

/**
 * CAC threshold change rule
 */
struct PACKED morse_cmd_cac_change_rule
{
    /** Threshold in Authentication Request Frames per Second */
    __le16 arfs;
    /** Percentage change to apply to threshold if condition is matched */
    __sle16 threshold_change;
};

/**
 * @brief Request message for CAC
 */
struct PACKED morse_cmd_req_cac
{
    /** CAC subcommand @ref morse_cmd_cac_op */
    uint8_t opcode;
    /** Number of threshold change rules */
    uint8_t rule_tot;
    /** Threshold change rule (%) */
    struct morse_cmd_cac_change_rule rule[MORSE_CMD_CAC_CFG_CHANGE_RULE_MAX];
};

/**
 * @brief Response message for CAC
 */
struct PACKED morse_cmd_resp_cac
{
    /** Number of threshold change rules */
    uint8_t rule_tot;
    /** Threshold change rule (%) */
    struct morse_cmd_cac_change_rule rule[MORSE_CMD_CAC_CFG_CHANGE_RULE_MAX];
};


#define MORSE_CMD_IFNAMSIZ 16

/**
 * @brief Request message for MBSSID
 */
struct PACKED morse_cmd_req_mbssid
{
    /** Maximum supported BSS to be updated in MBSSID IE */
    uint8_t max_bssid_indicator;
    /** Beacon or probe reponse transmitting interface name */
    int8_t transmitter_iface[MORSE_CMD_IFNAMSIZ];
};

#define MORSE_CMD_MESH_ID_LEN_MAX              32
#define MORSE_CMD_MESH_BEACONLESS_MODE_DISABLE 0
#define MORSE_CMD_MESH_BEACONLESS_MODE_ENABLE  1
#define MORSE_CMD_MESH_PEER_LINKS_MIN          0
#define MORSE_CMD_MESH_PEER_LINKS_MAX          10

/**
 * @brief Request message for SET_MESH_CONFIG
 *
 * Structure derived from struct morse_mesh_config in morse.h in the driver
 */
struct PACKED morse_cmd_req_set_mesh_config
{
    /** Mesh ID Len */
    uint8_t mesh_id_len;
    /** Mesh ID, equivalent to SSID in infra */
    uint8_t mesh_id[MORSE_CMD_MESH_ID_LEN_MAX];
    /** Mesh beaconless mode enabled/disabled */
    uint8_t mesh_beaconless_mode;
    /** Maximum number of peer links */
    uint8_t max_plinks;
};

/**
 * @brief Request message for SET_MCBA_CONF
 */
struct PACKED morse_cmd_req_set_mcba_conf
{
    /** Configuration to enable or disable MBCA TBTT Selection and Adjustment */
    uint8_t mbca_config;
    /** Beacon Timing Element Report interval */
    uint8_t beacon_timing_report_interval;
    /** Minimum gap between our beacon and neighbor beacons */
    uint8_t min_beacon_gap_ms;
    /** Initial scan duration to find neighbor mesh peers in the MBSS */
    __le16 mbss_start_scan_duration_ms;
    /** TBTT adjustment timer interval in LMAC firmware */
    __le16 tbtt_adj_interval_ms;
};

/**
 * @brief Request message for DYNAMIC_PEERING_CONFIG
 */
struct PACKED morse_cmd_req_dynamic_peering_config
{
    /** Enable or disable mesh dynamic peering */
    uint8_t enabled;
    /** RSSI margin to consider while selecting a peer to kick out */
    uint8_t rssi_margin;
    /** Kicked out peer is not allowed connection during this period */
    __le32 blacklist_timeout;
};

#define MORSE_CMD_CFG_RAW_FLAG_ENABLE  BIT(0)
#define MORSE_CMD_CFG_RAW_FLAG_DELETE  BIT(1)
#define MORSE_CMD_CFG_RAW_FLAG_UPDATE  BIT(2)
#define MORSE_CMD_CFG_RAW_FLAG_DYNAMIC BIT(3)

enum morse_cmd_raw_tlv_tag
{
    MORSE_CMD_RAW_TLV_TAG_SLOT_DEF = 0,
    MORSE_CMD_RAW_TLV_TAG_GROUP = 1,
    MORSE_CMD_RAW_TLV_TAG_START_TIME = 2,
    MORSE_CMD_RAW_TLV_TAG_PRAW = 3,
    MORSE_CMD_RAW_TLV_TAG_BCN_SPREAD = 4,
    MORSE_CMD_RAW_TLV_TAG_DYN_GLOBAL = 5,
    MORSE_CMD_RAW_TLV_TAG_DYN_CONFIG = 6,
    MORSE_CMD_RAW_TLV_TAG_LAST = 7,
};

/**
 * Slot definition is required for new raw configs
 */
struct PACKED morse_cmd_raw_tlv_slot_def
{
    uint8_t tag;
    /** Total length of the RAW window. @ref raw_duration_us / num_slots = slot_duration */
    __le32 raw_duration_us;
    /** Number of individual "slots" within the RAW window */
    uint8_t num_slots;
    uint8_t cross_slot_bleed;
};

/**
 * RAW group information
 */
struct PACKED morse_cmd_raw_tlv_group
{
    uint8_t tag;
    /** Start AID for this raw config */
    __le16 aid_start;
    /** End AID for this config (inclusive) */
    __le16 aid_end;
};

/**
 * RAW start time information
 */
struct PACKED morse_cmd_raw_tlv_start_time
{
    uint8_t tag;
    /** Time the RAW window starts, measured from the end of the frame carrying RPS IE */
    __le32 start_time_us;
};

/**
 * Periodic RAW information
 */
struct PACKED morse_cmd_raw_tlv_praw
{
    uint8_t tag;
    uint8_t periodicity;
    uint8_t validity;
    uint8_t start_offset;
    uint8_t refresh_on_expiry;
};

/**
 * RAW beacon spreading information
 */
struct PACKED morse_cmd_raw_tlv_bcn_spread
{
    uint8_t tag;
    __le16 max_spread;
    __le16 nominal_sta_per_bcn;
};

/**
 * Global configuration for dynamic RAW configuration
 */
struct PACKED morse_cmd_raw_tlv_dyn_global
{
    uint8_t tag;
    /** Number of dynamic RAW confgis present */
    __le16 num_configs;
    /** The maximum number of beacon frames to add RAW configs to */
    __le16 num_bcn_indexes;
};

/**
 * Single dynamic RAW config entry in the batch of RAW configs
 */
struct PACKED morse_cmd_raw_tlv_dyn_config
{
    uint8_t tag;
    /** Unique config id of dynamic RAW config entry */
    __le16 id;
    /** Index of beacon to include this RAW config into */
    __le16 index;
    /** Length of RAW config */
    __le16 len;
    /** RAW TLV data */
    uint8_t variable[];
};

/**
 * RAW TLV data
 */
union PACKED morse_cmd_raw_tlvs
{
    uint8_t tag;
    struct morse_cmd_raw_tlv_slot_def slot_def;
    struct morse_cmd_raw_tlv_group group;
    struct morse_cmd_raw_tlv_start_time start_time;
    struct morse_cmd_raw_tlv_praw praw;
    struct morse_cmd_raw_tlv_bcn_spread bcn_spread;
    struct morse_cmd_raw_tlv_dyn_global dyn_global;
    struct morse_cmd_raw_tlv_dyn_config dyn_config;
};

/**
 * @brief Request message for CONFIG_RAW
 */
struct PACKED morse_cmd_req_config_raw
{
    /** Flags for this RAW config */
    __le32 flags;
    /**
     * ID to reference this RAW config. If ID already exists, existing config will be overwritten.
     * ID of 0 is reserved to indicate operate on RAW globally.
     */
    __le16 id;
    /** RAW TLV data */
    uint8_t variable[];
};

#define MORSE_CMD_RATE_INFO_BW_MASK     15
#define MORSE_CMD_RATE_INFO_BW_SHIFT    0
#define MORSE_CMD_RATE_INFO_MCS_MASK    240
#define MORSE_CMD_RATE_INFO_MCS_SHIFT   4
#define MORSE_CMD_RATE_INFO_GUARD_MASK  256
#define MORSE_CMD_RATE_INFO_GUARD_SHIFT 8

/**
 * RC statistic entry
 */
struct PACKED morse_cmd_rc_stats_entry
{
    /** Bit field describing the rate this entry is about */
    __le32 rate_info;
    /** Total number of packets transmitted at this rate */
    __le32 total_sent;
    /** Total number of successful transmissions at this rate */
    __le32 total_success;
    /** Reserved for future expansion of the stats */
    __le32 unused;
};

/**
 * @brief Response message for GET_RC_STATS
 */
struct PACKED morse_cmd_resp_get_rc_stats
{
    /** Reserved for future expansion of the stats */
    uint8_t unused[8];
    __le32 n_entries;
    struct morse_cmd_rc_stats_entry entries[];
};

/**
 * @brief Request message for SET_TX_PKT_LIFETIME_USECS
 */
struct PACKED morse_cmd_req_set_tx_pkt_lifetime_usecs
{
    __le32 lifetime_usecs;
};

/**
 * @brief Response message for SET_TX_PKT_LIFETIME_USECS
 */
struct PACKED morse_cmd_resp_set_tx_pkt_lifetime_usecs
{
};

/**
 * @brief Request message for SET_PHYSM_WATCHDOG
 */
struct PACKED morse_cmd_req_set_physm_watchdog
{
    uint8_t physm_watchdog_en;
};

/**
 * @brief Request message for TX_POLAR
 */
struct PACKED morse_cmd_req_tx_polar
{
    uint8_t enable;
};


enum morse_cmd_otp_region
{
    /** OTP bank specified by the bank num */
    MORSE_CMD_OTP_REGION_ALL_BANK = 0,
    /** Access chip serial OTP bank */
    MORSE_CMD_OTP_REGION_SERIAL = 1,
    /** Access country code OTP bank */
    MORSE_CMD_OTP_REGION_COUNTRY = 2,
    /** Access board type OTP bank */
    MORSE_CMD_OTP_REGION_BOARDTYPE = 3,
};

/**
 * @brief Request message for OTP
 */
struct PACKED morse_cmd_req_otp
{
    /** Bool, 1=enabled, 0=disabled */
    uint8_t write_otp;
    uint8_t bank_num;
    __le32 bank_val;
    /** Can specify specific OTP bank region */
    uint8_t bank_region;
};

/**
 * @brief Response message for OTP
 *
 * Value written to the OTP bank
 */
struct PACKED morse_cmd_resp_otp
{
    __le32 bank_val;
};

/**
 * @brief Request message for MAX_AMPDU_LENGTH
 */
struct PACKED morse_cmd_req_max_ampdu_length
{
    __sle32 n_bytes;
};

/**
 * @brief Request message for MEDIUM_EVAL
 */
struct PACKED morse_cmd_req_medium_eval
{
    /** @ref enable/disable medium evaluation */
    uint8_t enable;
};


#define MORSE_CMD_HOST_BLOCK_TX_FRAMES BIT(0)
#define MORSE_CMD_HOST_BLOCK_TX_CMD    BIT(1)

enum morse_cmd_param_action
{
    MORSE_CMD_PARAM_ACTION_SET = 0,
    MORSE_CMD_PARAM_ACTION_GET = 1,
    MORSE_CMD_PARAM_ACTION_LAST = 2,
};

enum morse_cmd_slow_clock_mode
{
    /** Slow clock source would be automatically selected */
    MORSE_CMD_SLOW_CLOCK_MODE_AUTO = 0,
    /** Slow clock source would be set to internal */
    MORSE_CMD_SLOW_CLOCK_MODE_INTERNAL = 1,
};

enum morse_cmd_param_id
{
    MORSE_CMD_PARAM_ID_MAX_TRAFFIC_DELIVERY_WAIT_US = 0,
    MORSE_CMD_PARAM_ID_EXTRA_ACK_TIMEOUT_ADJUST_US = 1,
    MORSE_CMD_PARAM_ID_TX_STATUS_FLUSH_WATERMARK = 2,
    MORSE_CMD_PARAM_ID_TX_STATUS_FLUSH_MIN_AMPDU_SIZE = 3,
    MORSE_CMD_PARAM_ID_POWERSAVE_TYPE = 4,
    MORSE_CMD_PARAM_ID_SNOOZE_DURATION_ADJUST_US = 5,
    MORSE_CMD_PARAM_ID_TX_BLOCK = 6,
    MORSE_CMD_PARAM_ID_FORCED_SNOOZE_PERIOD_US = 7,
    MORSE_CMD_PARAM_ID_WAKE_ACTION_GPIO = 8,
    MORSE_CMD_PARAM_ID_WAKE_ACTION_GPIO_PULSE_MS = 9,
    MORSE_CMD_PARAM_ID_CONNECTION_MONITOR_GPIO = 10,
    MORSE_CMD_PARAM_ID_INPUT_TRIGGER_GPIO = 11,
    MORSE_CMD_PARAM_ID_INPUT_TRIGGER_MODE = 12,
    MORSE_CMD_PARAM_ID_COUNTRY = 13,
    MORSE_CMD_PARAM_ID_RTS_THRESHOLD = 14,
    MORSE_CMD_PARAM_ID_HOST_TX_BLOCK = 15,
    MORSE_CMD_PARAM_ID_MEM_RETENTION_CODE = 16,
    MORSE_CMD_PARAM_ID_NON_TIM_MODE = 17,
    MORSE_CMD_PARAM_ID_DYNAMIC_PS_TIMEOUT_MS = 18,
    MORSE_CMD_PARAM_ID_HOME_CHANNEL_DWELL_MS = 19,
    MORSE_CMD_PARAM_ID_SLOW_CLOCK_MODE = 20,
    MORSE_CMD_PARAM_ID_FRAGMENT_THRESHOLD = 21,
    MORSE_CMD_PARAM_ID_BEACON_LOSS_COUNT = 22,
    MORSE_CMD_PARAM_ID_LAST = 23,
};

/**
 * @brief Request message for GET_SET_GENERIC_PARAM
 */
struct PACKED morse_cmd_req_get_set_generic_param
{
    /** The param to perform the action on [enum morse_cmd_param_id] */
    __le32 param_id;
    /** The action to take on the param [get | set] */
    __le32 action;
    /** Any flags to modify the behavior of the action (for forwards/backwards compatibility) */
    __le32 flags;
    /** The value to set (only applicable for set actions) */
    __le32 value;
};

/**
 * @brief Response message for GET_SET_GENERIC_PARAM
 */
struct PACKED morse_cmd_resp_get_set_generic_param
{
    /**
     * Any flags to signal change of interpretation of response - forwards / backwards compatibility
     */
    __le32 flags;
    /** The value returned (only applicable for get actions) */
    __le32 value;
};

#endif // MORSE_COMMANDS_H_
